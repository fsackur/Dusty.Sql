function Get-SqlAgReplica {
<#
    .Synopsis
    Gets information about all replicas in all availability groups

    .Description
    Queries the server specified by the Instance parameter and finds all availability groups that that instance is part of. Returns information about all replicas in all those availability groups.

    Uses the current user account to connect to SQL.

    .Parameter Instance
    Specifies the instance to query for AG membership

    .Example
    Get-SqlAgReplicas -Instance PARISDB2\ACCOUNTS | Format-Table

    Returns all replicas in all AGs that the PARISDB2\ACCOUNTS instance is part of, and formats as a table
#>
    param(
        [string]$Instance
    )

    <#
        Explanation.

        We want information from multiple tables in one query. That's how SQL works.

        These tables have properties such as replica_id, which hold GUIDs that are the same in each table.
        For further reading, investigate Primary Keys. In this query, we are using group_id in both JOIN
        statements.

        We use the "AS" statements so that we can refer more easily to the columns we want to select.

        The INNER JOIN statement tells SQL to produce one row of output for each individual combination of
        rows from the two tables in the JOIN statement. The output row is generated by patching up the
        columns in the predicate - that is, ON repl.group_id = ag.group_id. So if you have one row in one
        table with '172f2f83-29af' and two rows in the other table with the same value, you will get two
        rows in the output. In the first INNER JOIN, that's no problem at all. But in the second INNER
        JOIN, the peculiarity of sys.dm_hadr_availability_replica_states bites us, because it holds a row
        for each AG that it hosts istself and also a row for each primary in each AG where it isn't a
        primary itself. Then we would get rows that we don't want. So we make a subclause for the INNER
        JOIN in the second one that filters on the WHERE is_local = 1 predicate.

        To me, this is advanced magic. HTH. Freddie
    #>
    $Query = "
        DECLARE @ServerName NVARCHAR(128)
        SET @ServerName = CONVERT(NVARCHAR(128), (SELECT SERVERPROPERTY('ServerName')))

        SELECT
	        ag.name
	        , @ServerName AS replica
            , repl.availability_mode_desc
	        , repl.failover_mode_desc
	        , ars.role_desc

        FROM sys.availability_replicas AS repl

	        INNER JOIN sys.availability_groups AS ag
	        ON repl.group_id = ag.group_id

            INNER JOIN (
		        SELECT
			        role_desc
			        ,group_id
		        FROM
			        sys.dm_hadr_availability_replica_states
		        WHERE
			        is_local = 1
	        ) AS ars
	        ON repl.group_id = ars.group_id

        WHERE repl.replica_server_name = @ServerName
    "

    #Get all instances involved in AGs
    $Instances = Get-SqlAgInstance -Instance $Instance

    #We can only get primary/secondary info on the current instance, so we need to run this query against each SQL server for a complete picture
    $Instances | foreach {
        Invoke-Sqlcmd -ServerInstance $_ -Query $Query

    #Convert to a PSObject so we can be clever about formatting
    } | foreach {

        New-Object psobject -Property @{
            AvailabilityGroup = $_.name;
	        Replica = $_.replica;
	        AvailabilityMode = $_.availability_mode_desc;
	        FailoverMode = $_.failover_mode_desc;
	        Role = $_.role_desc;
        }

    #Apply formatting
    } | foreach {

        Add-DefaultMembers `
            -InputObject $_ `
            -SortProperties AvailabilityGroup, Replica `
            -DisplayProperties AvailabilityGroup, Replica, AvailabilityMode, Role `
            -TypeName "Rax.SqlAgReplica" `
            -PassThru            #return to pipeline

    }
}
