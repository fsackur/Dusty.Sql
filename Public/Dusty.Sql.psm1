<#
    Author: Freddie Sackur
    (c) 2017 Freddie Sackur. All rights reserved.
#>

#Requires -Modules Formatting

function Get-SqlAgReplica {
<#
    .Synopsis
    Gets information about all replicas in all availability groups
    
    .Description
    Queries the server specified by the Instance parameter and finds all availability groups that that instance is part of. Returns information about all replicas in all those availability groups.

    Uses the current user account to connect to SQL.

    .Parameter Instance
    Specifies the instance to query for AG membership

    .Example
    Get-SqlAgReplicas -Instance PARISDB2\ACCOUNTS | Format-Table

    Returns all replicas in all AGs that the PARISDB2\ACCOUNTS instance is part of, and formats as a table
#>
    param(
        [string]$Instance
    )

    <#
        Explanation.

        We want information from multiple tables in one query. That's how SQL works.

        These tables have properties such as replica_id, which hold GUIDs that are the same in each table.
        For further reading, investigate Primary Keys. In this query, we are using group_id in both JOIN
        statements.

        We use the "AS" statements so that we can refer more easily to the columns we want to select.

        The INNER JOIN statement tells SQL to produce one row of output for each individual combination of
        rows from the two tables in the JOIN statement. The output row is generated by patching up the
        columns in the predicate - that is, ON repl.group_id = ag.group_id. So if you have one row in one 
        table with '172f2f83-29af' and two rows in the other table with the same value, you will get two 
        rows in the output. In the first INNER JOIN, that's no problem at all. But in the second INNER 
        JOIN, the peculiarity of sys.dm_hadr_availability_replica_states bites us, because it holds a row 
        for each AG that it hosts istself and also a row for each primary in each AG where it isn't a 
        primary itself. Then we would get rows that we don't want. So we make a subclause for the INNER 
        JOIN in the second one that filters on the WHERE is_local = 1 predicate.

        To me, this is advanced magic. HTH. Freddie
    #>
    $Query = "
        DECLARE @ServerName NVARCHAR(128)
        SET @ServerName = CONVERT(NVARCHAR(128), (SELECT SERVERPROPERTY('ServerName')))

        SELECT
	        ag.name
	        , @ServerName AS replica
            , repl.availability_mode_desc
	        , repl.failover_mode_desc
	        , ars.role_desc

        FROM sys.availability_replicas AS repl

	        INNER JOIN sys.availability_groups AS ag
	        ON repl.group_id = ag.group_id
	    
            INNER JOIN (
		        SELECT
			        role_desc
			        ,group_id
		        FROM
			        sys.dm_hadr_availability_replica_states
		        WHERE
			        is_local = 1
	        ) AS ars
	        ON repl.group_id = ars.group_id
        
        WHERE repl.replica_server_name = @ServerName
    "

    #Get all instances involved in AGs
    $Instances = Get-SqlAgInstance -Instance $Instance

    #We can only get primary/secondary info on the current instance, so we need to run this query against each SQL server for a complete picture
    $Instances | foreach {
        Invoke-Sqlcmd -ServerInstance $_ -Query $Query

    #Convert to a PSObject so we can be clever about formatting
    } | foreach {
        
        New-Object psobject -Property @{
            AvailabilityGroup = $_.name;
	        Replica = $_.replica;
	        AvailabilityMode = $_.availability_mode_desc;
	        FailoverMode = $_.failover_mode_desc;
	        Role = $_.role_desc;
        }

    #Apply formatting
    } | foreach {
        
        Add-DefaultMembers `
            -InputObject $_ `
            -SortProperties AvailabilityGroup, Replica `
            -DisplayProperties AvailabilityGroup, Replica, AvailabilityMode, Role `
            -TypeName "Rax.SqlAgReplica" `
            -PassThru            #return to pipeline

    }
}



function Get-SqlAgDatabase {
<#
    .Synopsis
    Gets information about all databases in all availability groups
    
    .Description
    Queries the server specified by the Instance parameter and finds all availability groups that that instance is part of. Returns information about all databases in all those availability groups.

    Uses the current user account to connect to SQL.

    By default, only returns information about databases that are replicated as part of an availability group.

    .Parameter Instance
    Specifies the instance to query for AG membership

    .Parameter IncludeNonReplicatedDatabases
    Include user databases that exist on a replica but are not part of any availability group replication

    .Example
    Get-SqlAgDatabase -Instance PARISDB2\ACCOUNTS | Format-Table

    Returns all replicas in all AGs that the PARISDB2\ACCOUNTS instance is part of, and formats as a table
#>
    param(
        [string]$Instance,
        [switch]$IncludeNonReplicatedDatabases
    )

    if ($IncludeNonReplicatedDatabases) {
        $JoinType = "LEFT OUTER"
    } else {
        $JoinType = "INNER"
    }
    
    $Query = "
        DECLARE @ServerName NVARCHAR(128)
        SET @ServerName = CONVERT(NVARCHAR(128), (SELECT SERVERPROPERTY('ServerName')))

        SELECT
	        ag.name AS availability_group 
	        , @ServerName AS replica
	        , db.name
	        , db.database_id AS id
	        , db.state_desc
	        , dbrs.synchronization_state_desc
	        , dbrs.group_database_id
	        , dbrcs.is_failover_ready
            , dbrs.is_primary_replica

        FROM sys.databases AS db
        $JoinType JOIN sys.dm_hadr_database_replica_states AS dbrs --include non-replicated DBs
        ON dbrs.database_id = db.database_id

        $JoinType JOIN sys.dm_hadr_database_replica_cluster_states AS dbrcs
        ON dbrcs.group_database_id = dbrs.group_database_id AND dbrcs.replica_id = dbrs.replica_id

        $JoinType JOIN sys.availability_groups AS ag
        ON ag.group_id = dbrs.group_id

        WHERE
            (dbrs.is_local = 1 OR dbrs.is_local IS NULL)
            AND
            db.database_id NOT IN (1,2,3,4)
    "


    #Get all instances involved in AGs
    $Instances = Get-SqlAgInstance -Instance $Instance


    #We can only get primary/secondary info on the current instance, so we need to run this query against each SQL server
    $InstanceDBs = $Instances | foreach {
        Invoke-Sqlcmd -ServerInstance $_ -Query $Query
    }

    #Convert to a PSObject so that we can be clever about formatting
    $InstanceDBs | foreach {
        
        New-Object psobject -Property @{
            AvailabilityGroup = $_.availability_group | where {$_ -isnot [DBNull]};
            Replica = $_.replica;
            Database = $_.name;
            DatabaseId = $_.id;
            DatabaseState = $_.state_desc;
            SynchronizationState = $_.synchronization_state_desc;
            AgDatabaseId = $_.group_database_id;
            IsFailoverReady = $_.is_failover_ready | where {$_ -isnot [DBNull]};
            IsPrimary = $_.is_primary_replica | where {$_ -isnot [DBNull]};
            
        }

    #Apply formatting
    } | foreach {
        
        Add-DefaultMembers `
            -InputObject $_ `
            -SortProperties AvailabilityGroup, Replica `
            -DisplayProperties AvailabilityGroup, Replica, Database, IsFailoverReady, IsPrimary `
            -TypeName "Rax.SqlAgDatabase" `
            -PassThru            #return to pipeline

    }
    
}

function Get-SqlAgInstance {
    param(
        [string]$Instance
    )

    Invoke-Sqlcmd `
        -ServerInstance $Instance `
        -Query "SELECT DISTINCT (replica_server_name) FROM sys.availability_replicas" | 
            select -ExpandProperty replica_server_name

}


function Get-SqlAgFailoverReadiness {
<#
    .Synopsis
    Gets information about failover readiness of all replicas in all availability groups
    
    .Description
    Queries the server specified by the Instance parameter and finds all availability groups that that instance is part of. Returns information about all replicas in all those availability groups.

    Uses the current user account to connect to SQL.

    IsFailoverReady is true if all databases on a replica are failover-ready. If this property shows false on a secondary and you fail over the primary replica to this secondary, you will have to accept data loss. To make this show true, you will need to set the current primary and the target secondary replicas to Synchronous Commit mode and wait.

    HasNonReplicatedDatabases is true if there are any user databases present on an instance that are not replicated in an availability group. These databases may experience downtime along with the server they reside on unless they have another high-availability strategy.
    
    .Parameter Instance
    Specifies the instance to query for AG membership

    .Example
    Get-SqlAgFailoverReadiness -Instance PARISDB2\ACCOUNTS | Format-Table

    Returns all replicas in all AGs that the PARISDB2\ACCOUNTS instance is part of, and formats as a table
#>
    param(
        [string]$Instance
    )

    $DBs = Get-SqlAgDatabase @PSBoundParameters -IncludeNonReplicatedDatabases

    $ReplicatedDBs = $DBs | where {$null -ne $_.IsPrimary}
    
    $NonReplicatedDBs = $DBs | where {$null -eq $_.IsPrimary}
        
    $Replicas = $ReplicatedDBs |
        #This puts the "false" above the "true" for IsFailoverReady
        sort AvailabilityGroup, Replica, IsFailoverReady -Unique |
        #This removes the "true" for IsFailoverReady
        sort AvailabilityGroup, Replica -Unique |
        #strip out DB-related properties
        select AvailabilityGroup, Replica, IsPrimary, IsFailoverReady
        

    foreach ($Replica in $Replicas) {

        $Replica |

            Add-Member -MemberType NoteProperty -Name NonReplicatedDatabases -Value (
                $NonReplicatedDBs | where {$_.Replica -eq $Replica.Replica} | select -ExpandProperty Database
            ) -PassThru |

            Add-Member -MemberType ScriptProperty -Name HasNonReplicatedDatabases -Value {
                    $null -ne $_.NonReplicatedDatabases
                } -PassThru |
            
            Add-DefaultMembers `
                -SortProperties AvailabilityGroup, Replica `
                -DisplayProperties AvailabilityGroup, Replica, IsPrimary, IsFailoverReady, HasNonReplicatedDatabases `
                -TypeName "Rax.SqlAgReplica" `
                -PassThru        #write to pipeline

    }


}

Export-ModuleMember -Function Get-Sql* -Alias *
